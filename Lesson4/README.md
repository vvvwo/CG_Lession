# 三维模型变换

本课程介绍OpenGL是如何处理模型-全局-观察矩阵变换，包括齐次坐标变换、观察矩阵计算以及在顶点着色器里的流水线处理。可以说这部分是OpenGL前半部分最重要的知识点。如果你希望完成FPS游戏Demo，那么你必须要熟练掌握模型变换的数学基础以及在OpenGL的处理流程，尤其是在顶点着色器中的几个矩阵变换。一旦熟练掌握，那么处理复杂的三维变换计算将会变得非常容易！

## 1. 齐次坐标变换

如果你对线性代数和矩阵计算稍有了解，那么就该知道如果我们希望对一个点添加一个变换，那么这个变换可以以矩阵乘法的形式执行。譬如存在一个点p(x,y,z), 我希望将点进行一个以原点为起点的拉伸，拉伸的倍数为a。我们最终希望获得的坐标是p(ax,ay,az)。这个拉伸过程就可以被看做是一个变换，自然这个变换能够被写成矩阵计算的形式：

<img height = "100" alt="equ" src="https://github.com/user-attachments/assets/1b532cdc-634e-4493-b877-6834e5bbc4ef">

除此之外，我们还能将点p按照一个特定的轴进行旋转（绕Z轴旋转，角度为θ1）：

<img height = "100" alt="fig1" src="https://github.com/user-attachments/assets/ca83e5bd-c1e3-4658-86bb-26f621ada072">

<img height ="100" alt="equ2" src="https://github.com/user-attachments/assets/5f2b4e6f-b71b-4087-a171-96f853a94651">

绕其他两轴的变换矩阵也是类似的，这里我直接写出来：

（绕X轴旋转，角度为θ1）：

<img height = "100" alt="fig2" src="https://github.com/user-attachments/assets/792a9059-53fa-4307-95f4-ee823fcc5a3f">

（绕Y轴旋转，角度为θ1）：

<img height = "100" alt="fig3" src="https://github.com/user-attachments/assets/e4473117-f2f1-47eb-9345-a84171be91c2">

我们知道，基础变换是包含平移、旋转和缩放的，平移可以写成如下形式：

<img height = "33" alt="fig4" src="https://github.com/user-attachments/assets/f4c1d1c3-3e8b-42c6-8016-7c30b17c4990">

这里有一个问题，平移是以矩阵加法的形式执行的，缩放和旋转则是矩阵乘法的形式来执行的。当我们需要组合各种复杂的变换来驱动对应的三维计算或动画模拟时，我们显然希望统一矩阵计算形式，这样在顶点着色器中处理更加容易。另外，我们还需要区分当前的数据是一个点，还是一个向量，此时如果按照三维空间的三坐标形式来建立变换矩阵和数据表达，就不能满足要求。齐次坐标就是用来解决这个问题，其形式就是增加一维，使得点的坐标从三维扩展到四维，变换矩阵变为4*4，这样，所有的变换都能够写成矩阵乘法，平移变为：

<img height = "133" alt="fig3" src="https://github.com/user-attachments/assets/dd506f28-c74a-4e50-a5c1-8b0cc8d2d57e">

点的最后一位为1，向量的最后一位为0，这样点和向量（或平移变换）的计算就不会改变标识位，使得计算保持形式上的统一。

$${\color{red}注：在实际的计算中，矩阵是前置的，因此会与我的写法有一些不同，但是只要了解原理，变换计算顺序不会影响你对齐次坐标变换的理解。}$$

## 2. 观察矩阵

试想，我们如果希望绘制一个三维场景，首选需要建立这个三维场景，然后选择一个合适的观察角度，完成绘制，就像画家绘画一样。当我们把模型放在正确的位置后，接下来我们要根据预定义的观察或摄像机局部坐标系统，将全局的模型表达变换到摄像机局部坐标系。观察矩阵的齐次坐标变换就是用来执行这个任务的。

首先我们要知道观察矩阵对应的局部坐标系统：

![image](https://github.com/user-attachments/assets/fdaef2f3-c438-4671-852e-28c6e914603e)

如图所示，我们在三维空间中有一个摄像机。这个摄像机是对应一个局部坐标系统的。我们希望将全局坐标系统的物体映射到这个局部坐标系统中，以”正确的“展示在该视角下的全局场景的样貌。此时，我们知道摄像机的位置，以及摄像机观察的方向Direction。那么我们如何获得这个局部坐标系统呢？

这里是有一个trick的，即辅助方向的引入。这里的辅助方向指的Y轴正方向。首先我们使用观察方向和Y轴正方向做叉乘，获得一个正右方向right。之后再对right和Direction做一个叉乘，得到朝上方向up。此时我们获得了对于摄像机局部坐标系统的三个正交轴(Direction，right，up)。我们根据这三个新的坐标轴，从原始全局坐标轴起步，就能够反推得到全局坐标系统到摄像机局部坐标系统的变换矩阵。这个变换矩阵就被视为观察矩阵的齐次变换。

OpenGL封装了上述计算，使得变成人员只提供必要的输入，就能利用LookAt函数，直接算出观察矩阵的齐次变换，如下：

<pre class="prettyprint"><code class=" hljs xml">glm::mat4 view; 
view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), 
glm::vec3(0.0f, 1.0f, 0.0f)
);
</code></pre>

glm::lookAt的第一个参数是摄像机的全局坐标，第二个参数是其观察的点坐标，第三个参数是默认的朝上坐标。lookAt函数直接输出观察矩阵的齐次坐标变换view，当我们需要执行从全局坐标到摄像机局部坐标的变换时，只需要前置乘以view，就实现了该变换。在顶点着色器里，这个变换就能够写成一个比较规整的形式

## 3. 顶点着色器矩阵变换

一般在默认的顶点着色器里，我们可能会看到下面一段语句：

<pre class="prettyprint"><code class=" hljs xml">gl_Position = projection * view * model * vec4(aPos, 1.0f);</code></pre>

这里的vec4就是输入顶点着色器的原始坐标，前置的矩阵projection,view,model就是我们在前一个章节讲的齐次坐标变换，view就是观察矩阵的齐次坐标变换。那么另外两个矩阵是干什么的？

回想上一章内容，我们如果希望绘制一个三维场景，首选需要建立这个三维场景，然后选择一个合适的观察角度，完成绘制，就像画家绘画一样。三维模型的数字表示形式，可能都是在一个特定的坐标系建立的。我们希望把三维模型摆放在我们定义的场景中，就相当于我们要把模型放在一个正确的位置上。模型变换矩阵model就是执行这样一个变换过程。当我们把模型放在正确的位置后，接下来我们要根据预定义的观察或摄像机局部坐标系统，对应view变换。最后，我们在局部坐标系下，要决定绘制投影画面的大小，透视变换的细节等，那么就是由projection实现的。projection,view,model基本对应了顶点着色器最主要的齐次变换，实现了从模型坐标-全局坐标-摄像机局部坐标的变换。
